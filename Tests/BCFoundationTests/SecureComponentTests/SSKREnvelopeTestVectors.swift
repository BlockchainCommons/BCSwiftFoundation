import XCTest
import BCFoundation
import WolfBase

final class SSKREnvelopeTestVectors: XCTestCase {
    let fakeContentKey = SymmetricKey(‡"526afd95b2229c5381baec4a1788507a3c4a566ca5cce64543b46ad12aff0035")!
    let fakeNonce = Nonce(‡"4d785658f36c22fb5aed3ac0")!
    let fakeRandomGenerator = DeterministicRandomNumberGenerator(‡"dca8cfe8e67d03fab4177279d5498e7a")
    
    lazy var seedPayload: Seed = {
        var seed = Seed(data: ‡"59f2293a5bce7d4de59e71b4207ac5d2")!
        seed.name = "Dark Purple Aqua Love"
        seed.creationDate = try! Date(iso8601: "2021-02-24")
        seed.note = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
        return seed
    }()
    
    let stringPayload = "It is the unspoken ethic of all magicians to not reveal the secrets. -- David Copperfield"

    func testGenerateSSKREnvelopeTestVectors() throws {
        print("# SSKR Test Vectors")
        print("")
        print("This document provides test vectors for scenarios where `crypto-envelope` is used with SSKR to shard and recover secrets of any size. It is generated by `SSKREnvelopeTestVectors.testGenerateSSKREnvelopeTestVectors()` in the `BCSwiftFoundation` test suite.")
        print("")
        print("These objects are normally random, but they are fixed for these test vectors:")
        print("")
        print("* Symmetric key used for encryption: `\(fakeContentKey.data.hex)`")
        print("* Nonce for encryption: `\(fakeNonce.data.hex)`")
        print("* Random generator for SSKR returns repeating sequence: `\(fakeRandomGenerator.data.hex)`")

        try runTestCase(
            index: 1,
            name: "Seed 2 of 3",
            payload: seedPayload,
            groupThreshold: 1,
            groups: [(2, 3)],
            recoveredShareIndexes: [0, 2],
            expectedFirstShare: "ur:crypto-envelope/lftpdylrhdprayfevdfmyaioutghbycxkpdynngmimcnzclaghbnskdeoycxeetigelultvlplfetnotsfamfpueeyluaykbsbweryvywkatsfattdpshdahbecyhpsrrlossabydkgutnmteecsaojodaloghiatkynosdydpjkctgeswuolyvaecptfzwygdbbnsswfgahqdrdfmuyhelpzmmsynrsttgdgtistsadbybtcalphsntgalacpbzwelkwlfldrynselegduowdkptsrlamnnrpiemuonfssgktloteidtkneckbaztktnndelrgouehtdngopyrdcnldhgrtlntybadypainvyaxcypagsgtkshfhdwfjzcpzohtweftrtgdnsosoxenhebdmnmycmrnnysetepatdayhddktpethdcxaygrjzeeguftwpianbtlfmpkeyjepylnhdosktgelpleielnrnpllafmrdmdflsblftpehtpfntpframtpehtpfntaadechddapduoaeadaefltivlttcloxssbnadahlsbdghcmcwuyatwnjliomwtkvaflztlnghfhfeplnthkwlpmlgqd"
        )
        
        try runTestCase(
            index: 2,
            name: "String 3 of 5 with Additional Assertion",
            payload: stringPayload,
            groupThreshold: 1,
            groups: [(3, 5)],
            recoveredShareIndexes: [0, 2, 4],
            note: "This could be vendor-specific data attached to the envelope.",
            expectedFirstShare: "ur:crypto-envelope/lstpdylrhdhpptcalfwytahyyllngsjpgruemtjsztsnvlhebycscxnetsldfltehejkvyrtrdjntswnsgflkosacnmoahkpmklkrozoregawscelrrkesbdbaemhdmeoloelthddifesfldjsayckeyimtshkdyvovlwnetdkendeasmttkluzscxonfgyngygsgtkshfhdwfjzcpzohtweftrtgdgtwsfdzcattabtlyptoevsdtleeyfncyhddktpethdcxpdnecmfmzchgaedppackpandielkfpzospynvtckjlhdatonweswceuyaxvehffrlftpehtpfntpfraatpehtpfnksfnghisinjkcxiajlkpjziecxidihcxkoihjtiejljpdpjkjoihiainiyiniacxiehsjyhscxhsjyjyhsiaisihiecxjyjlcxjyisihcxihjtkoihjzjljoihdmlftpehtpfntpframtpehtpfntaadechddapduoaeaoaetkvsvakiaxzsqzchjpkktlgamnknuopdtkvsvakiaxzsqzchjpkktlgamnknuopdkpssrops"
        )
        
        try runTestCase(
            index: 3,
            name: "Seed 2-of-3 of 2-of-3",
            payload: seedPayload,
            groupThreshold: 2,
            groups: [(2, 3), (2, 3), (2, 3)],
            recoveredShareIndexes: [0, 1, 6, 7],
            expectedFirstShare: "ur:crypto-envelope/lftpdylrhdprayfevdfmyaioutghbycxkpdynngmimcnzclaghbnskdeoycxeetigelultvlplfetnotsfamfpueeyluaykbsbweryvywkatsfattdpshdahbecyhpsrrlossabydkgutnmteecsaojodaloghiatkynosdydpjkctgeswuolyvaecptfzwygdbbnsswfgahqdrdfmuyhelpzmmsynrsttgdgtistsadbybtcalphsntgalacpbzwelkwlfldrynselegduowdkptsrlamnnrpiemuonfssgktloteidtkneckbaztktnndelrgouehtdngopyrdcnldhgrtlntybadypainvyaxcypagsgtkshfhdwfjzcpzohtweftrtgdnsosoxenhebdmnmycmrnnysetepatdayhddktpethdcxaygrjzeeguftwpianbtlfmpkeyjepylnhdosktgelpleielnrnpllafmrdmdflsblftpehtpfntpframtpehtpfntaadechddapduobgadaehsjklgrevenybbimhfnyrtfrgakoueindpdpweetoyfhadfshliyjlihtoptasjewnldurkk"
        )
    }
    
    func runTestCase<T>(
        index: Int,
        name: String,
        payload: T,
        groupThreshold: Int,
        groups: [(Int, Int)],
        recoveredShareIndexes: Set<Int>,
        note: String? = nil,
        expectedFirstShare: String
    ) throws where T: CBORCodable {
        let shares = try generateShares(from: payload, groupThreshold: groupThreshold, groups: groups, note: note)
        
        try XCTAssertEqual(UR(urString: expectedFirstShare), shares.first!.first!.ur)

        print("")
        print("## TEST VECTOR \(index): \(name)")
        print("")
        
        print("### PAYLOAD")
        print(payload.cbor.diagAnnotated.markdownMonospaced)
        
        for (groupIndex, groupShares) in shares.enumerated() {
            for (shareIndex, share) in groupShares.enumerated() {
                print("\n### GROUP \(groupIndex + 1) SHARE \(shareIndex + 1)")
                print("#### UR")
                print(share.ur†.markdownMonospaced)
                print("#### Tagged CBOR Binary")
                print(share.taggedCBOR.hex.markdownMonospaced)
                print("#### Tagged CBOR Diagnostic Notation")
                print(share.taggedCBOR.diagAnnotated.markdownMonospaced)
                print("#### Tagged CBOR Annotated Binary")
                print(share.taggedCBOR.dump.markdownMonospaced)
                print("---")
            }
        }

        let recoveredShares = shares.flatMap { $0 }.enumerated().compactMap { index, share in
            recoveredShareIndexes.contains(index) ? share : nil
        }
        
        let recoveredPayload = try recoverPayload(T.self, shares: recoveredShares)
        XCTAssertEqual(payload.cbor, recoveredPayload.cbor)
    }

    func generateShares(from payload: CBOREncodable, groupThreshold: Int, groups: [(Int, Int)], note: String?) throws -> [[Envelope]] {
        // Enclose the payload in an envelope.
        var envelopeWithPayload = Envelope(payload)
        if let note {
            envelopeWithPayload = envelopeWithPayload.add(.note, note)
        }
        
        // Encrypt the envelope with the content key. This is the key that will be split below using SSKR.
        let encryptedEnvelope = try envelopeWithPayload.encrypt(with: fakeContentKey, nonce: fakeNonce)
        
        // Split the encrypted envelope into shares.
        fakeRandomGenerator.reset()
        let shares = encryptedEnvelope.split(
            groupThreshold: groupThreshold,
            groups: groups,
            contentKey: fakeContentKey,
            randomGenerator: {
                self.fakeRandomGenerator.data(count: $0)
            }
        )
        
        return shares
    }
    
    func recoverPayload<T: CBORDecodable>(_ payloadType: T.Type, shares: [Envelope]) throws -> T {
        // Use SSKR to join the shares into the original envelope. If the shares are not
        // valid, an exception will be thrown.
        let joinedEnvelope = try Envelope(shares: shares)
        
        // Extract the original payload from the envelope.
        return try joinedEnvelope.extract(payloadType)
    }
}

extension String {
    var markdownMonospaced: String {
        self.flanked("```\n", "\n```")
    }
}
